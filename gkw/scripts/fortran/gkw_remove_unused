#!/bin/bash
#
#######################################################################
# This script removes redundant "use, xx only : " statements from 
# fortran 90 source code.  It relies on the sister script 
# gkw_check_use_unused for a list of routines and variables to remove. 
# The list is progressively updated by modifying temporary files and 
# therefore depends heavily on the output format of the sister script.  
#
# usage: gkw_remove_unused *90
#
# The files are modified in place, so this should only be done on a
# clean svn checkout.  If the code compiles and passes test cases,
# everthing is probably fine, but it is anyway wise to check things 
# by eye. So far all replacements tested have been quite robust 
# and none have broken compilation, but some variables may be missed 
# (see limitations below)
#
# Limitations:
# Misses top of module use statements (because of sister script)
# Misses uppercase FUNCTION / SUBROUTINE / END or routine names
# Misses variables after line continuation characters
# Misses orphaned "use, x only :" statements when followed by comments
# May rely on up to date versions of standard linux tools
# (sed, perl, tail, awk, tr, csplit, cut, sort)
# May rely on certain code formatting conventions (e.g. lowercase)
#
# F J Casson, August 2013
#######################################################################

tmpfile=/tmp/tmpfile1232134wfd
tmpfile2=/tmp/tmpfile1232134wfc

# loop over passed arguments
until [[ -z "$1" ]]; do
  
  # Store the list of variables and routines from the sister script in a temporary file
  rm -rf $tmpfile $tmpfile2
  $GKW_HOME/scripts/fortran/gkw_check_use_unused $1 > $tmpfile
  
  #remove the first two header lines of temporary file
  tail -n +3 $tmpfile > $tmpfile2
  rm $tmpfile

  # remove the first subroutine line containing UNUSED
  tail -n +2 $tmpfile2 > $tmpfile

  # loop over subroutines listed in the flie
  for subs in `grep UNUSED $tmpfile2 | cut -d " " -f 11 | sed 's/://'`; do
    
    #make subroutine names lowercase (from all uppercase in script output)
    subs=`echo $subs | tr '[A-Z]' '[a-z]'`
    
    echo Subroutine $subs

    # loop over listed variables in first subroutine until next UNUSED in file
    # for var in `awk '/UNUSED/{exit}1' $tmpfile`; do
    # also sort the arguments by length, do the longest first to avoid 
    # partial matches variables with similar names
    for var in `awk '/UNUSED/{exit}1' $tmpfile | awk '{ print length, $0 }' | sort -n -r | cut -d" " -f2-`; do  
      
      echo "   Remove" $var #from $1

      # Do not match substrings
      var2='[^a-zA-Z0-9_]'${var}'[^a-zA-Z0-9_]'
      var3='[^a-zA-Z0-9_]'${var}'[ ]*$'
      var4=${var}'[^a-zA-Z0-9_]'
      var5='[^a-zA-Z0-9_]'${var}

      #Perform sed substitutions only in given subroutine or function blocks      
      #http://stackoverflow.com/questions/6945621/using-sed-to-remove-a-block-of-text
      #http://www.ibm.com/developerworks/linux/library/l-sed2/index.html
      # /I operator makes sed replaces case insensitive (may not be present in older versions of sed)
      # but does not seem to help in selecting the blocks, which must be lowercase

      # remove those in middle of lists
      sed -i "/subroutine ${subs}/,/end subroutine ${subs}/Is/\(use.*,[ ]*only.*\)\(,[ ]*${var4}\)/\1,/I" $1 
      # remove those at end of lists
      sed -i "/subroutine ${subs}/,/end subroutine ${subs}/Is/\(use.*,[ ]*only.*\)\(,[ ]*${var3}\)/\1/I" $1 
      # remove those at start of lists      
      sed -i "/subroutine ${subs}/,/end subroutine ${subs}/Is/\(use.*,[ ]*only.*\)\(${var5},[ ]*\)/\1 /I" $1
      sed -i "/subroutine ${subs}/,/end subroutine ${subs}/Is/\(use.*,[ ]*only.*\)\(${var5}[ ]*,[ ]*\)/\1 /I" $1
      # remove those on their own
      sed -i "/subroutine ${subs}/,/end subroutine ${subs}/Is/\(use.*,[ ]*only.*\)\(${var3}\)/\1/I" $1
      
      # same as above but for functions
      sed -i "/function ${subs}/,/end function ${subs}/Is/\(use.*,[ ]*only.*\)\(,[ ]*${var4}\)/\1,/I" $1  
      sed -i "/function ${subs}/,/end function ${subs}/Is/\(use.*,[ ]*only.*\)\(${var3}\)/\1/I" $1
      sed -i "/function ${subs}/,/end function ${subs}/Is/\(use.*,[ ]*only.*\)\(${var5},[ ]*\)/\1 /I" $1
      sed -i "/function ${subs}/,/end function ${subs}/Is/\(use.*,[ ]*only.*\)\(${var5}[ ]*,[ ]*\)/\1 /I" $1  
      sed -i "/function ${subs}/,/end function ${subs}/Is/\(use.*,[ ]*only.*\)\(${var3}\)/\1/I" $1
         
    done
    
    # remove orphaned "use, x only: " lines    
    # need perl for negative lookahead (not in sed) 
    # http://stackoverflow.com/questions/2973436/regex-lookahead-lookbehind-and-atomic-groups
    # http://www.regular-expressions.info/lookaround.html
    # perl -p -i -n -e 's/use.*[ ]*only[ ]*:[ ](?!\b\w\b)$//' $1 
    # but substitution does not remove the entire line
    # perl -p -i -n -e 's/use.*[ ]*only[ ]*:[ ]*$//' $1 
   
    # easier to use end of line matching in perl
    # http://stackoverflow.com/questions/80415/perl-regex-match-and-removal 
    perl -ni -e 'print unless /use.*[ ]*only[ ]*:[ ]*$/' $1 
         
    #remove completed vars and routines from top of temporary file
    csplit -s $tmpfile /UNUSED/
    mv -f xx01 $tmpfile2
    rm $tmpfile
    tail -n +2 $tmpfile2 > $tmpfile  
 
  done  

  rm -f xx00
  
  shift
  
done

