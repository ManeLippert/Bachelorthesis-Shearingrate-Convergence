#!/bin/sh
#  -*-Perl-*-  (for Emacs)    vim:set filetype=perl:  (for vim)
#============================================================================#
# Run the right perl version:
if [ -x /usr/local/bin/perl ]; then
  perl=/usr/local/bin/perl
elif [ -x /usr/bin/perl ]; then
  perl=/usr/bin/perl
else
  perl=`which perl| sed 's/.*aliased to *//'`
fi
#
exec $perl -x -S $0 "$@";     # -x: start from the following line
#============================================================================#
#! /Good_Path/perl -w
# line 17
#
# Name: gkw_check_unused_use
# Author:  andrew.snodin (aps.code@gmail.com)
# Date:   29-Sep-2010
# Description:
#
#   Check for any redundant variables in USE statements in Fortran routines
#   (or at least the ones in GKW). Input is list of file names. This may
#   become part of a more comprehensive check at some point.
#
# Issues:
#
#   * does not deal with USE statements outside subroutines (easy to fix)
#   * (possibly?) does not find redundant trailing ",&"
#
#============================================================================#

use strict;

my %UsedVariables;
my %UnusedVariables;
my @files;
my $debug = 0;
my $varprefix = '[^a-zA-Z0-9_]';     # DO NOT match any valid name characters
my $varsuffix = '($|[^a-zA-Z0-9_])'; # match end of line, or NOT any valid name

if (@ARGV) {
    @files = @ARGV ; chomp(@files);
}

# process each input file
foreach my $file (@files) {

    # clean out for next file
    foreach my $nlist ( keys %UnusedVariables ) {
        delete $UnusedVariables{$nlist};
    }
    # clean out for next file
    foreach my $nlist ( keys %UsedVariables ) {
        delete $UsedVariables{$nlist};
    }


    # Run through the file once to collect unused variables
    check_file($file);

    # print a summary for this file
    print "===============================================================\n";
    print "* In file $file:\n";
    # compare the arrays for each key in input
    if ($debug) {
        foreach my $nlist ( keys %UsedVariables ) {
            if ($#{ $UsedVariables{$nlist} } ge 0) {
                print "    USED variables in USE statements for $nlist:\n";
                foreach my $i ( 0 .. $#{ $UsedVariables{$nlist} } ) {
                    if (defined($UsedVariables{$nlist}[$i])) {
                        print "      $UsedVariables{$nlist}[$i]\n";
	                }
                }
            }
        }
    }
    foreach my $nlist ( keys %UnusedVariables ) {
        if ($debug) { print "Trying to output for $nlist\n"; }
        if ($debug) { print "  (There are $#{ $UnusedVariables{$nlist} } entries)\n"; }
        if ($#{ $UnusedVariables{$nlist} } ge 0) {
            print "    UNUSED variables in USE statements for $nlist:\n";
            foreach my $i ( 0 .. $#{ $UnusedVariables{$nlist} } ) {
                if (defined($UnusedVariables{$nlist}[$i])) {
                    print "      $UnusedVariables{$nlist}[$i]\n";
	            }
            }
        }
    }

}

#-----------------------------------------------------------------------------
# read a source file and fill a hash of used variables

sub check_file {

    my $file = shift;
    open(INPUT,"<$file") || die "can not open file $file\n";

    my $in_sub = 0;
    my $imused;
    my $varwasused;
    my $subname = "";
    my $use_also_nextline = 0;
    my @DefinedLocalVars;
    my @UsedLocalVars;
    my @UnusedLocalVars;

    # read through the whole file a line at a time
    while( my $line = <INPUT> ) {

        chomp($line);

        # Check if we are at the start of a routine; get the subroutine name
        # and initialise the array @uselocalvars to collect variables from
        # USE statements.
        if ($line =~ /^\s*subroutine/i || $line =~ /^\s*recursive/i ||
        $line =~ /^\s*function/i || $line =~ /^\s*pure/i) {
            $in_sub = 1;
            @DefinedLocalVars = (); @UsedLocalVars = (); @UnusedLocalVars =();
            my @words = split " ", $line;
            if( $words[1] =~ /^\s*function/i ||
            $words[1] =~ /^\s*subroutine/i) {
                ( $subname = $words[2] ) =~ tr/a-z/A-Z/;
            } else {
                ( $subname = $words[1] ) =~ tr/a-z/A-Z/;
            }
            $subname =~ s/\s//g;
            $subname =~ s/\(.*$//;
        }

	    # Check if we are at the end of a routine; flush the list of variables
        # to a hash of variables with the subroutine name as the key.
        if ($line =~ /^\s*end\s*(subroutine|recursive|function|pure)/i) {
            $in_sub = 0;
            foreach my $var (@DefinedLocalVars) {
                $varwasused = 0;
                foreach my $localvar (@UsedLocalVars) {
                    if ( "$localvar" eq "$var" ) { $varwasused = 1; }
                }
                push (@UnusedLocalVars,$var) unless ($varwasused);
            }
            if ($debug) {
                print "Flush for $subname\n";
                foreach my $lv (@UnusedLocalVars) {
                    print "   -> $lv is **** unused ****\n";
                }
                foreach my $lv (@UsedLocalVars) {
                    print "   -> $lv is USED\n";
                }
             }
            $UnusedVariables{$subname} = [ @UnusedLocalVars ];
            $UsedVariables{$subname} = [ @UsedLocalVars ];
        }

        # Collect all the variables after the "only".
        if (($line =~ /^\s*use\s*.+\s*\,\s*only/i && $in_sub) ||
	    $use_also_nextline) {
            # flag to look at the next line if a continuation is found
            $use_also_nextline = 0;
            my $usenames = $line;
            $usenames =~ s/^\s*\&//;
            $usenames =~ s/^\s*use\s*.+\s*\,\s*only\s*\://i;
            $usenames =~ s/\!.*$//g;
            $usenames =~ s/\s//g;
            $use_also_nextline = 1 if ($usenames =~ /\&/);
            $usenames =~ s/\&//g;
            $usenames =~ s/\=\>\s*\w*//g;
            $usenames =~ tr/A-Z/a-z/;
            my @uwords = split ",", $usenames;
            foreach my $word (@uwords) {
                push @DefinedLocalVars, $word;
                if ($debug) { print "+ Adding $word to defined for $subname\n"; }
            }
        } else {       # delete variables as they are found
            if ($in_sub) {
                # ignore comments
                if (not $line =~ /^\s*\!/i) {
                    foreach my $var (@DefinedLocalVars) {
                        if ($line =~ /$varprefix$var$varsuffix/i) {
                            if ($debug) { print "- Removing $var from used for $subname\n"; }
                            $imused = 0;
                            foreach my $usedvar (@UsedLocalVars) {
                              if ( "$usedvar" eq "$var") { $imused = 1; }
                            }
                            push (@UsedLocalVars,$var) unless ($imused);
                        }
                    }
                }
            }
        }
    }

    close(INPUT);
}
