#! /bin/tcsh
#######################################################################
# GKW loadleveler batch launcher script configured for Babel BG/P
# Separate script from gkwnlin as Babel case is quite special:
# the file server is different from the computing server and
# multistep jobs are required.
# Most of the script is a copy/paste from gkwnlin though.
# 
# For usage instructions call script with --help.
#
# Original version,       A G Peeters: gkwlin      2008
# Extended functionality, F J Casson:  gkwnlin     2008-11
#
# Works with general geometry if correct location 
# of geometry file hamada.dat is specified in input.dat
#
# Works for restarting a run with new or old input file.
# Keeps ALL output files.
#
#######################################################################

if ( $#argv == 0 ) then
  echo For usage call with --help
  exit(0)
endif

if ( "x$argv[1]" == "x-h" || "x$argv[1]" == "x-help" || "x$argv[1]" == "x-v" || "x$argv[1]" == "x--help" ) then
  echo '***********************************************'
  echo 
  echo  Script that launches batches of GKW runs 
  echo
  echo  The executable used is the most recent in '$GKW_HOME/run=':
  echo
  echo  A correct directory structure, as created with 
  echo  
  echo    gkwnlin -p name 
  echo 
  echo  where name is the name of the project, is assumed to exist on the
  echo  fileserver Gaya
  echo 
  echo  First, create input files in the appropriate folder on Gaya
  echo  then launch from the script on Babel
  echo
  echo  '  usage  : gkwnlin [-np 8] [-th 2] [-h 16] [-restart] -p project file1 file2 file3'  
  echo
  echo  '  example: gkwnlin -np 32 -h 4 mygkwin*'
  echo 
  echo  'If used, the [options] must appear IN THE ORDER ABOVE.'
  echo
  echo  'where  -np X    specfies the number of processes (default 1)'
  echo  '       -th X    is the number of threads per process (default 1)'
  echo  '       -h       selects number of hours of runtime (default is ten minutes)'
  echo  '       -restart will restart a run using existing files '
  echo  '                and when finished will overwrite the existing files'
  echo  '       -p X     is the project name'
  echo  
  echo  Restarts can also be made using the restart files of a previous run
  echo 
  echo     'usage: gkwnlin [resource options] [-restart_file run_to_restart] input1 input2'
  echo 
  echo  'This will read restart files from run_to_restart (for both input1 and input2)' 
  echo  so no files will be overwritten.
  echo
  echo  To use with general geometry, the hamada.dat
  echo  can be located in the inputs folder and set
  echo  eqfile='../../input/hamada.dat' in the input
  echo
  echo  if max_sec lowercase exists in your input file, it will be reset 
  echo  correctly to correspond to the walltime of the job script.
  echo
  echo '***********************************************'
  exit(0)
endif 

#Set variable defaults
set host=`hostname | cut -c 1-3`
set PROC_INFO=0
set procs=1
set sub_cmd='llsubmit'
set threads=1
set mode=VN
set folders=1
set runcommand='mpirun'
set qext='ll'
set time=20:00:00
set VPBS='#@ '
set gkwgayaroot='runs/gkw'
set GKW_HOME=$HOME/codes/gkw-idris

  ########################################################################
  # Option parsing depends on ORDER! - please improve (use getopts)
  ########################################################################

  echo Running on $host

  # Always run the latest version of the code for the current machine
  set code=`ls -t $GKW_HOME/run/gkw*.x | grep $host`
  echo The version of the executable : $code[1]

   ##Get number of procs for parallel runs
   if ( "$argv[1]" == "-np" ) then
       shift
           set procs=$argv[1]
       shift
   else
      set procs=1
   endif
   echo Running on $procs procs

   if ( "$argv[1]" == "-th" ) then
       shift
           set threads=$argv[1]
       shift
   else
      set threads=1
   endif


   if ( "$argv[1]" == "-h" ) then
      shift
           set time=$argv[1]':00:00'
           set hours=$argv[1]
           set seconds=`expr $hours \* 3600`
      shift
   endif

   set restart=0
   set restart_file=0

   if ( "$argv[1]" == "-restart" ) then
           set restart=1
           set restart_file=0
           echo
           echo 'Restart files will be read from directory name of input file'
           echo 'Existing final output data and restart files will be overwritten'
           echo 'Append files will be extended'
           echo
      shift
   else
      set restart=0
   endif

   if ( "$argv[1]" == "-restart_file" ) then
           set restart=1
           set restart_file=1
      shift
      set run_to_restart=$argv[1]
      echo Restarting new input files with restart data from $run_to_restart
      shift
   endif

   if ( "$argv[1]" == "-p" ) then
       shift
           set proj=$argv[1]
       shift
   else
      echo Project folder not specified
      exit(1)
   endif
   echo Running project $proj

  ########################################################################
  # Per host settings follow
  # See http://services.tacc.utexas.edu/index.php/batch-systems-comparison
  ########################################################################

  #resource request and other settings tailored by host

  if ( $host == 'bab' ) then # Babel BG/P cluster

    set cores=4    # nb of cores per node
    set tasks=`expr $cores / $threads` #MPI tasks per node
    @ processors = $procs * $threads #total processors
    set nodes=`expr $processors / $cores`   #nodes required
    if ( $nodes == 0 ) set nodes=1
    if ( $nodes >= 512 ) then
      set bg_connect='TORUS'
    else
      set bg_connect='MESH'
    endif
    if ( $threads == 1 ) then
      set mode='VN'
      set env=
    else if ( $threads == 2 ) then
      set mode='DUAL'
      set env='-env "OMP_NUM_THREADS=2 XLSMPOPTS=spins=0:yields=0:stack=64000000"'
    else if ( $threads == 4 ) then
      set mode='SMP'
      set env='-env "OMP_NUM_THREADS=4 XLSMPOPTS=spins=0:yields=0:stack=64000000"'
    else
      echo Only threads=1,2,4 is allowed
      exit(1)
    endif   

    echo 'MPI tasks:        '   $procs
    echo 'Threads per task: '   $threads
    echo 'Processors:       '   $processors
    echo 'Nodes:            '   $nodes
    echo 'BG connection:    '   $bg_connect
    echo 'Mode:             '   $mode

  else #Host not known
     echo unknown host $host, please configure.
     exit(0)

  endif #host


  ##########################################################################

echo Runcommand: $runcommand

set gkwworkdir=$WORKDIR/runs  # work directory on Babel
                               # once the job is submitted it is running in $TMPDIR
cd $gkwworkdir

while ($#argv)
  ( mfget  $gkwgayaroot/$proj/input/$argv[1] dum > /dev/null ) >& errfile
  if ( ! -z errfile ) then   
    echo $argv[1] : file does not exist
  else
    rm dum
    echo "----------------------------------------------------------------------"
    echo $argv[1] : preparing the run
 
    set runname=$argv[1]:t 
    set subdir=$gkwworkdir/$runname  # directory from which the script will be submitted
    mkdir $subdir
    set qname=$subdir/$runname.$qext    




    # write the script to submit the loadleveller multistep job
    #
  #=========== Global directives ===========
    echo $VPBS shell = /bin/bash      > $qname
    echo $VPBS job_name = $runname   >> $qname
    echo $VPBS output = '$(job_name).$(step_name).$(jobid).o' >> $qname
    echo $VPBS error  = '$(job_name).$(step_name).$(jobid).e' >> $qname
  #=========== Step 1 directives ===========
    #======== Get files from Gaya     ========
    echo $VPBS step_name = getf         >> $qname
    echo $VPBS job_type  = serial       >> $qname
    echo $VPBS class     = archive      >> $qname 
    echo $VPBS cpu_limit = 0:15:00      >> $qname 
    echo $VPBS queue                    >> $qname
  #=========== Step 2 directives ===========
    #======= Sequential preprocessing ========
    echo $VPBS step_name = preproc      >> $qname
    echo $VPBS dependency = '(getf == 0)' >> $qname     # 0: submit only if previous step completed without error
    echo $VPBS job_type  = serial       >> $qname
    echo $VPBS cpu_limit = 0:15:00      >> $qname
    echo $VPBS queue                    >> $qname
  #=========== Step 3 directives ===========
    #============= Parallel step =============
    echo $VPBS step_name  = parallel    >> $qname
    echo $VPBS dependency = '(preproc == 0)'    >> $qname   # 0: submit only if previous step completed without error
    echo $VPBS job_type   = bluegene    >> $qname
    echo $VPBS bg_size    = $nodes       >> $qname
    echo $VPBS bg_connection = $bg_connect    >> $qname
    echo $VPBS wall_clock_limit = $time       >> $qname
    echo $VPBS queue                    >> $qname
  #=========== Step 4 directives ===========
    #======= Sequential postprocessing =======
    echo $VPBS step_name  = postproc    >> $qname  
    echo $VPBS dependency = '(parallel >= 0)'  >> $qname    # >=0: submit even if previous step completed with an error
    echo $VPBS job_type   = serial      >> $qname
    echo $VPBS class      = archive     >> $qname
    echo $VPBS cpu_limit  = 0:15:00     >> $qname
    echo $VPBS queue                    >> $qname  
    #=========== Step 5 directives ===========
    #======= Put files on Gaya         =======
    echo $VPBS step_name  = putf    >> $qname
    echo $VPBS dependency = '(postproc >= 0)'  >> $qname    # >=0: submit even if previous step completed with an error
    echo $VPBS job_type   = serial  >> $qname
    echo $VPBS class      = archive >> $qname 
    echo $VPBS cpu_limit  = 0:15:00 >> $qname
    echo $VPBS queue                >> $qname
    # 
    # Steps description
    echo 'case $LOADL_STEP_NAME in' >> $qname
  #======= Step 1: Get Gaya files  ========
    echo getf ')'                   >> $qname
    echo set -x                    >> $qname
    echo 'cd $tmpdir'               >> $qname
    if ( $restart == 1 ) then
       if ( $restart_file == 0) then
         set run_to_restart=$runname 
       endif
       echo Restarting with data from $run_to_restart
       echo mfget $gkwgayaroot/$proj/restart/$run_to_restart/FD'*'    >> $qname
       echo mfget $gkwgayaroot/$proj/restart/$run_to_restart/IN'*'    >> $qname
       echo mfget $gkwgayaroot/$proj/time/$run_to_restart  ./time.dat   >> $qname
       echo mfget $gkwgayaroot/$proj/fluxes/$run_to_restart  ./fluxes.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/fluxes/em/$run_to_restart  ./fluxes_em.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/fluxes/bpar/$run_to_restart  ./fluxes_bpar.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/kyspec/$run_to_restart  ./kyspec    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/kxspec/$run_to_restart  ./kxspec    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/kyvort/$run_to_restart  ./kyvort    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/kxvort/$run_to_restart  ./kxvort    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/kyspec_em/$run_to_restart  ./kyspec_em    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/kxspec_em/$run_to_restart  ./kxspec_em    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/eflux/$run_to_restart  ./eflux_spectra.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/pflux/$run_to_restart  ./pflux_spectra.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/vflux/$run_to_restart  ./vflux_spectra.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/eflux_kx/$run_to_restart  ./eflux_xspec.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/pflux_kx/$run_to_restart  ./pflux_xspec.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/vflux_kx/$run_to_restart  ./vflux_xspec.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/eflux_em/$run_to_restart  ./eflux_em_spectra.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/pflux_em/$run_to_restart  ./pflux_em_spectra.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/vflux_em/$run_to_restart  ./vflux_em_spectra.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/eflux_em_kx/$run_to_restart ./eflux_em_xspec.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/pflux_em_kx/$run_to_restart  ./pflux_em_xspec.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/spectrum/vflux_em_kx/$run_to_restart  ./vflux_em_xspec.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/parallel/phi_time/$run_to_restart  ./parallel_phi.dat    >> $qname
       echo mfget $gkwgayaroot/$proj/parallel/apar_time/$run_to_restart  ./parallel_apar.dat    >> $qname
    endif
    echo mfget $gkwgayaroot/$proj/input/$runname ./input.dat    >> $qname
    echo ';;'                         >> $qname 
  #======= Step 2: sequential preprocessing ========
    echo preproc ')'                  >> $qname
    echo set -ex                    >> $qname
    echo 'cd $tmpdir'               >> $qname
    # reset max_sec in input file (only if it exists in lowercase) appropriately
    echo  perl -p -i -n -e 's/max_sec.*$/max_sec='"${seconds}"'/g' '$tmpdir'/input.dat  >> $qname
    # set read_file=.true. if required
    if ( $restart == 1 ) then
      echo perl -p -i -n -e 's/read_file.*$/read_file=\.true\./g' '$tmpdir'/input.dat  >> $qname
    endif   
    echo cp $code[1] '$tmpdir'/gkw       >> $qname
    echo cp $GKW_HOME/scripts/gkw_construct-parallel-output.pl '$tmpdir'/parallel_rebuild.sh  >> $qname
    echo 'ln -s $tmpdir/time.dat ' $subdir/time_link            >> $qname
    echo 'ln -s $tmpdir/fluxes.dat ' $subdir/fluxes_link        >> $qname
    echo ';;'                         >> $qname
  #============ Step 3: parallel execution  ==========
    echo  parallel ')'               >> $qname
    echo  set -x                    >> $qname
    echo  'cd $tmpdir'              >> $qname
    echo $runcommand -mode $mode $env -np $procs -mapfile 'TXYZ -exe ./gkw > out'  >> $qname
    echo  ';;'                        >> $qname
  #============ Step 4: sequential postprocessing =======
    echo postproc ')'                 >> $qname
    echo set -x                     >> $qname
    echo cd '$tmpdir'                 >> $qname
    echo sh ./parallel_rebuild.sh   >> $qname
    echo cp $subdir/'*.parallel.*.o' ./$runname.o  >> $qname
    echo cp $subdir/'*.parallel.*.e' ./$runname.e  >> $qname
    echo ';;'                         >> $qname
  #============ Step 5:  put files on Gaya         =======
    echo putf ')'                     >> $qname
    echo set -x                     >> $qname
    echo cd '$tmpdir'                 >> $qname
    echo tar cvf $runname.tar '*'     >> $qname
    echo mfput $runname.tar  $gkwgayaroot/$proj/runs/$runname/$runname.tar       >> $qname
    echo ';;'                         >> $qname
    echo esac                      >> $qname

   # finally submit the job
    cd $subdir
    rm *.e
    rm *.o
    $sub_cmd $qname &

  endif #file existing
  rm  $gkwworkdir/errfile
  shift
end


