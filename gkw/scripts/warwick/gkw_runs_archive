#!/bin/bash
# Archival script works with directory structure of gkwnlin project.
# Script to assist with archival of gkw runs from work dir e.g. /gpfs
# (Quota limit is 250Gb)
#
# F.J.Casson 2009
#
# Default, All data backed up;
# Large data sets sent to space2
# Core data kept in home directory
#
#           Options: -mv: move not backup
#                    -c: remove directories in delete list
#                    -del: delete all but essential data 
#                    -n: rename single project subfolder name
#                    -s: use a subfolder in archive
# should be able to archive from main dir to backup dir 
#(some files on top of selves)
#####
# TO DO: 
# Preserve subdirectory structure for gkwpath.m
# fix same_folder
# option not to have duplicates in archive and main folders

##########################################################
# USER MODIFIABLE
##########################################################

#This directory for large data, not backed up
#Using rsync could be adapted to a remote machine
#e.g
archive_dir='/storage/space2/'$USER'/runs/gkw/'
#archive_dir='/media/disk/'$USER'/runs/gkw/'

#This directory for core data, backed up home directory
main_dir='/home/space/'$USER'/runs/gkw/'

#List of the directories that are kept in main by default
keep_list="input
time
fluxes
figs
fig
"
#out
#parallel/phi_time
#spectrum/kyspec
#spectrum/kxspec
#spectrum/vflux
#spectrum/eflux
#spectrum/eflux_kx
#spectrum/eflux_kx
#"

#List of the directories that are deleted with -c option
#and are not archived to anywhere ever.
delete_list="runs
spectrum/spc
spectrum/phi
out/pbs"

##########################################################
# END USER MODIFIABLE
##########################################################

#All other directories are archived by default, use -a or -i to override

if [[ -z $1 ]]
 then
    echo
    echo "  GKW project archival script: configure paths and lists first:"
    echo "  Main:    $main_dir"
    echo "  Archive: $archive_dir"
    echo
    echo "  usage: gkw_archive [options] project* (expands wildcards)"
    echo 
    echo "  where [options] must appear in the following order:"
    echo "    -mv : remove existing files as opppose to default of backup only"
    echo "    -c : clean; directories in delete_list will not be archived"
    echo "    -del : purge; only directories in keep_list will be archived"
    echo "     using -mv with -c or -del will result in data being deleted"
    echo
    echo "    -s folder_name: use a subfolder in archive"
    echo "    -n dir_name : rename the project in the archive (for single project only) "
    echo
    echo "  Run from the folder containing the projects you wish to archive"
    echo "  using -b with -c or -del will create a partial backup."
    echo "  By default all data is kept "
    echo "  Ensure you understand before using! "
    echo
    exit
 fi

#Default values, before read from options parsing
all=1
interactive=0
rename=0
#mv_cmd="cp -r"
mv_cmd="ionice -c2 -n7 rsync -avu"
#See http://bugzilla.csc.warwick.ac.uk/bugzilla/show_bug.cgi?id=3643
clean=0
purge=0
flag=0
same_folder=0
backup=1
subfolder=""

svn up ~/runs/gkw/runs_log


 if [[ $1 == '-mv' ]]
 then
    echo Move files, not backup: Existing files will be removed.
    backup=0
    mv_cmd="ionice -c2 -n7 rsync -avu --remove-source-files"
    shift
 else 
    echo Backup only: All existing files will remain.
 fi

 if [[ $1 == '-c' ]]
 then
    if [[ $backup -eq 0 ]]; then
         echo Directories $delete_list will be REMOVED!!
    else 
         echo Directories $delete_list will NOT be archived.
    fi
    clean=1
    all=0
    shift
 fi

 if [[ $1 == '-del' ]]
 then
    if [[ $clean -eq 1 ]]
    then
      echo option -c not compatible with -del
      exit
    fi

    if [[ $backup -eq 0 ]]; then
        echo ALL directories EXCEPT keep_list will be REMOVED!!
    else 
        echo ONLY directories $keep_list will be archived.
    fi
   
    purge=1
    all=0
    shift
 fi
 
 if [[ $1 == '-s' ]]
 then
    shift
    subfolder=$1"/"
    shift
 fi

 if [[ $1 == '-n' ]]
 then
    rename=1
    shift
    new_name=$1
    shift
    echo $1 will be renamed to $new_name.
 fi

 #Account for archiving from main dir
 if [[ "$main_dir${subfolder%/}" == `pwd` ]]; then
    same_folder=1
    echo Cannot currently archive into same folder, need fixing.
    exit
    #echo Current folder is main folder: Selected will only be moved to $archive_dir
    if [[ backup -eq 1 ]]; then
      echo use with option -mv to move selected folders to $archive_dir
      exit
    fi
 fi

echo keep_list:  $keep_list
echo will go to main:  $main_dir$subfolder
echo any remaining go to archive: $archive_dir$subfolder

# echo Options: 
# echo "Move or backup?:" $backup $mv_cmd 
# echo "Keep all files?" $all 
# echo "Remove files in delete list:" $clean 
# echo "Remove all files not in keep list:" $purge

echo Proceed: y/n?
read OPTION
    if [ $OPTION != 'y' ]; then
      echo abort
      exit
    fi

top_dir=`pwd`
#echo $all $interactive $rename $new_name

#Next argument(s) are project name(s)
##Loop through list of projects in expanded argument list.
until [[ -z "$1" ]]; do
  project=$1

  if [[ $rename == 1 && $flag == 0 ]]; then
    pro_main_dir=$main_dir$subfolder$new_name
    pro_archive_dir=$archive_dir$subfolder$new_name
    flag=1
  else
    pro_main_dir=$main_dir$subfolder$project
    pro_archive_dir=$archive_dir$subfolder$project
  fi
  
 #Check directory exists and is not a symlink
 if [[ ! -d "$project" || -h "$project" ]]; then
     echo $project does not exist here, skipping...
     shift
     continue
 fi

 mkdir -p $pro_main_dir
 mkdir -p $pro_archive_dir

 #Check target directories do not exist
 #This should mean that the -i options below are never invoked. 
#  if [[ -e "$pro_main_dir" && $same_folder -ne 1 ]]; then 
#      echo Target directory $pro_main_dir or $pro_archive_dir already exists, skipping...
#      shift
#      continue
#   fi
# 
#  if [[ -e "$pro_archive_dir" ]]; then
#      echo Target directory $pro_archive_dir already exists, skipping...
#      shift
#      continue
#  fi

  cd $project
  project_dir=`pwd`

  #echo $pro_main_dir
  #echo $pro_archive_dir
  #echo $project_dir
  
  if [[ ! -d input ]]; then 
    echo $project_dir is not a project directory 
    shift
    continue
  fi
  
  if [[ ! -d fluxes ]]; then 
    echo $project_dir is not a project directory 
    shift
    continue
  fi 

  mkdir -p $pro_main_dir
  if [[ $purge -ne 1 ]]; then
       mkdir -p $pro_archive_dir
  fi
 
  date >> $pro_main_dir/archive.log
  echo '*********************************************************'
  echo Archiving $project_dir:..... 2>&1 | tee -a $pro_main_dir/archive.log

  if [[ $backup -eq 1 && $all -eq 0 ]]; then #Keep all local data
	#"Hardlink" copy all directories
	# This is safest way to do it (although a bit slow) with backup / clean / purge options etc.
	echo creating duplicate hardlinks...
        mkdir ../tmp_hardlinks_asdfgh
	cp -r -l ./* ../tmp_hardlinks_asdfgh
	cd ../tmp_hardlinks_asdfgh
        echo "done"
  fi

  #Copy or move keep_list directories to new locations
  if [[ $same_folder -ne 1 ]]; then
      #Always keep all directories in keep list
      for file in $keep_list; do
        #echo $file
        $mv_cmd $file $pro_main_dir/ 2>&1 >> $pro_main_dir/archive.log
        #cp -r --parents -v -i -u $file $pro_main_dir 2>&1 >> $pro_main_dir/archive.log
      done
 
      #Always keep all top level files in project directory
      for file in `ls -p | grep -v "/"`; do
        #echo $file
        $mv_cmd $file $pro_main_dir/ 2>&1 >> $pro_main_dir/archive.log
      done
   fi

  #Remove unwanted (hardlinked) directories in delete_list
  if [[ $clean -eq 1 && $all -eq 0 ]]; then 
      for file in $delete_list; do
         rm -v -r $file 2>&1 >> $pro_main_dir/archive.log
      done
  fi

  #This bit is dangerous, removes all remaining data!
  if [[ $purge -eq 1 && $all -eq 0 && $clean -eq 0 ]]; then
     if [[ $backup==1 ]]; then
        rm -v -r $top_dir/tmp_hardlinks_asdfgh/* 2>&1 >> $pro_main_dir/archive.log
     else
        if [[ $backup==0 ]]; then
           rm -v -r $project_dir/* 2>&1 >> $pro_main_dir/archive.log
        fi
     fi
  fi

  #Archive all directories that remain.  Fails with files.
  if [[ $purge -eq 0 ]]; then
	for file in $( ls ); do
                #if [[ -d $file ]]; then #Disallow top level files
			$mv_cmd $file $pro_archive_dir 2>&1 >> $pro_main_dir/archive.log
			ln -T -s -v ./storage/$file $pro_main_dir'/'$file 2>&1 >> $pro_main_dir/archive.log
                #fi
	done
  fi

  #Allows flexible data relocation later
  ln -s -v $pro_archive_dir $pro_main_dir'/storage'

  cd .. #get back to projects directory

  if [[ $backup -ne 1 ]]; then   #Cleanup
  #Leave a symlink behind, can safely be deleted
      rmdir $project_dir
      #echo "${pro_main_dir%/}" #strip trailing slash since ln doesn't like it
      ln -s -i "${pro_main_dir%/}" $1 
  fi

  #Remove tmp directory
  if [[ $backup -eq 1 && $all -eq 0 ]]; then
      #echo $top_dir/tmp_hardlinks_asdfgh
      rm -rf $top_dir/tmp_hardlinks_asdfgh
  fi 

  # Keep a meta log here at top level too.
  echo ================================================= >> archive_meta.log
  echo `date` >> archive_meta.log
  echo $1 archived to $pro_main_dir  >> archive_meta.log
  echo with selected files to $pro_archive_dir >> archive_meta.log
  echo Options: >> archive_meta.log
  echo "Move or backup?:" $backup $mv_cmd >> archive_meta.log
  echo "Keep all files?" $all >> archive_meta.log
  echo "Remove files in delete list:" $clean >> archive_meta.log
  echo "Remove all files not in keep list:" $purge >> archive_meta.log

  # And in the runs log
   echo >> ~/runs/gkw/runs_log
   echo ================================================= >> ~/runs/gkw/runs_log
   echo `date` >> ~/runs/gkw/runs_log
   echo $1 archived to $pro_main_dir  >> ~/runs/gkw/runs_log

shift
done

exit