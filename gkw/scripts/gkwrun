#!/bin/bash

if [[ "x${1}" == "x--help" || "x${1}" == "x-h" ]] ; then
    scriptname=$(basename $0)
    cat <<EOF
 Usage: $scriptname [number_of_mpitasks]

 This script runs the latest GKW executable on the inputfile in the
 current folder with

    mpirun -np number_of_mpitasks <latest_executable_for_this_machine>

 The argument number_of_mpitasks defaults to 1 (i.e. a serial run) .

 For this script to find the lastest executable, \$GKW_HOME must be set.

 Examples:
   # to run the latest suitable executable in currrent directory:
   $scriptname

   # to run with 4 mpitasks with redirected input and output:
   $scriptname 4 &> log.txt

   # to run with 4 mpitasks, detached from the current shell, so that it continues after logout:
   ($scriptname 4 &> log.txt &)

EOF
    exit 0
fi


# mpi run command
mpiruncmd=mpirun
# new run command
new_run_cmd=gkwnewrun

source $GKW_HOME/scripts/gkwlib.sh

find_latest_executable

# start a new run if we are called with "gkw_new_run"
if [ `basename $0` = "${new_run_cmd}" ]; then
    gkw_clean_run
    #echo "THIS IS A FRESH RUN"
fi

if [ -z "$2" ]; then
    echo "Running local input.dat"
else
    if [ ! -e "input.dat" ]; then
	# if there is no file or link input.dat, link the second cmd line argument
	# to ./input.dat
        ln -s "$2" "input.dat"
    elif [ -L "input.dat" ]; then
	# if there is alread a link, remove it.
        rm -f "input.dat"
        ln -s "$2" "input.dat"
    else
        echo "local $PWD/input.dat exists, cannot create a link!"
        exit 1
    fi
fi

if [ -z "$1" ]; then
    echo "Running single process for ${latest_executable}"
    ( ${latest_executable} ) # I see no sense in having a subshell, but maybe there is one.
else
    echo "Running ${latest_executable} with $1 processes"
    ( ${mpiruncmd} -np $1 ${latest_executable})
fi

if [ $? -ne 0 ]; then
    echo "error running ${latest_executable}"
    exit 1
else
    exit 0
fi
