!-----------------------------------------------------------------------------
!> Modified subset of a f90 version of specfun as obtained from
!> http://people.sc.fsu.edu/~burkardt/f_src/specfun/specfun.html
!-----------------------------------------------------------------------------
module specfun

  implicit none

  private

  public :: sf_erf, bessj0, bessj1, bessi0, expbessi0, expbessi1, calci1
  public :: timestamp

  interface sf_erf
    module procedure specfun_erf
  end interface

  interface bessj0
    module procedure besj_0
  end interface

  interface bessj1
    module procedure besj_1
  end interface

  interface bessi0
    module procedure besi_0
  end interface

  interface expbessi0
    module procedure  besei0
  end interface

  interface expbessi1
    module procedure  besei1
  end interface

contains

!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!*****************************************************************************
function specfun_erf ( x )
!*****************************************************************************
!
!! R8_ERF evaluates the error function.
!
!  Discussion:
!
!    This routine computes approximate values for erf(x).
!
!    This routine was renamed from "DERF" to "R8_ERF" to avoid being
!    overshadowed by corresponding functions supplied by some compilers.
!
!    See comments heading CALERF.
!
!  Modified:
!
!    23 January 2008
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: R8_ERF, the value of the function.
!

  integer :: jint
  real :: specfun_erf
  real :: result
  real :: x

  jint = 0
  call calerf ( x, result, jint )
  specfun_erf = result

  return
end function specfun_erf

!****************************************************************************
!****************************************************************************

function specfun_erfc ( x )

!*****************************************************************************80
!
!! R8_ERFC evaluates the complementary error function.
!
!  Discussion:
!
!    This routine computes approximate values for erfc(x).
!
!    This routine was renamed from "DERFC" to "R8_ERFC" to avoid being
!    overshadowed by corresponding functions supplied by some compilers.
!
!    See comments heading CALERF.
!
!  Modified:
!
!    23 January 2008
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: R8_ERFC, the value of the function.
!
  implicit none

  integer :: jint
  real :: specfun_erfc
  real :: result
  real :: x

  jint = 1
  call calerf ( x, result, jint )
  specfun_erfc = result

  return
end function specfun_erfc

!****************************************************************************
!****************************************************************************

function specfun_erfcx ( x )

!*****************************************************************************80
!
!! R8_ERFCX evaluates the exponentially scaled complementary error function.
!
!  Discussion:
!
!    This routine computes approximate values for exp(x*x) * erfc(x).
!
!    This routine was renamed from "DERFCX" to "R8_ERFCX" to match the
!    renamings of DERF and DERFC.
!
!    See comments heading CALERF.
!
!  Modified:
!
!    23 January 2008
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: R8_ERFCX, the value of the function.
!
  implicit none

  integer :: jint
  real :: specfun_erfcx
  real :: result
  real :: x

  jint = 2
  call calerf ( x, result, jint )
  specfun_erfcx = result

  return
end function specfun_erfcx

subroutine calci0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCI0 computes various I0 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functions of the first kind
!    and order zero, I0(X) and EXP(-ABS(X))*I0(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of
!    minimax approximations generated by Blair and Edwards, Chalk
!    River (Atomic Energy of Canada Limited) Report AECL-4928,
!    October, 1974.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody, Laura Stoltz
!
!  Parameters:
!
!    Input, real :: ARG, the argument.  If JINT = 1, then
!    the argument must be less than XMAX.
!
!    Output, real :: RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = I0(x);
!    2, RESULT = exp(-x) * I0(x);
!
!    Input, integer :: JINT, chooses the function to be computed.
!    1, I0(x);
!    2, exp(-x) * I0(x);
!
  implicit none

  real :: a
  real :: arg
  real :: b
  real :: exp40
  real :: forty
  integer :: i
  integer :: jint
  real :: one
  real :: one5
  real :: p(15)
  real :: pp(8)
  real :: q(5)
  real :: qq(7)
  real :: result
  real :: rec15
  real :: sump
  real :: sumq
  real :: two25
  real :: x
  real :: xinf
  real :: xmax
  real :: xsmall
  real :: xx
!
!  Mathematical constants
!
  data one /1.0E0/
  data one5 /15.0E0/
  data exp40 /2.353852668370199854E17/
  data forty /40.0E0/
  data rec15 /6.6666666666666666666E-2/
  data two25 /225.0E0/
!
!data xsmall /5.55E-17/
!  data xinf /1.79E308/
!  data xmax /713.986E0/
!
!  Coefficients for XSMALL <= ABS(ARG) < 15.0
!
  data  p/-5.2487866627945699800E-18,-1.5982226675653184646E-14, &
          -2.6843448573468483278E-11,-3.0517226450451067446E-08, &
          -2.5172644670688975051E-05,-1.5453977791786851041E-02, &
          -7.0935347449210549190E+00,-2.4125195876041896775E+03, &
          -5.9545626019847898221E+05,-1.0313066708737980747E+08, &
          -1.1912746104985237192E+10,-8.4925101247114157499E+11, &
          -3.2940087627407749166E+13,-5.5050369673018427753E+14, &
          -2.2335582639474375249E+15/
  data  q/-3.7277560179962773046E+03, 6.5158506418655165707E+06, &
          -6.5626560740833869295E+09, 3.7604188704092954661E+12, &
          -9.7087946179594019126E+14/
!
!  Coefficients for 15.0 <= ABS(ARG)
!
  data pp/-3.9843750000000000000E-01, 2.9205384596336793945E+00, &
          -2.4708469169133954315E+00, 4.7914889422856814203E-01, &
          -3.7384991926068969150E-03,-2.6801520353328635310E-03, &
           9.9168777670983678974E-05,-2.1877128189032726730E-06/
  data qq/-3.1446690275135491500E+01, 8.5539563258012929600E+01, &
          -6.0228002066743340583E+01, 1.3982595353892851542E+01, &
          -1.1151759188741312645E+00, 3.2547697594819615062E-02, &
          -5.5194330231005480228E-04/
          
!  MACHINE-dependent constants
!
  XSMALL = epsilon(1.)
  XMAX = 5*sqrt(1./epsilon(1.))
  XINF=huge(1.)

  x = abs ( arg )

  if ( x < xsmall ) then

    result = one
!
!  XSMALL <= ABS(ARG) < 15.0.
!
  else if ( x < one5 ) then

    xx = x * x
    sump = p(1)
    do i = 2, 15
      sump = sump * xx + p(i)
    end do
    xx = xx - two25

    sumq = (((( &
        xx + q(1) ) &
      * xx + q(2) ) &
      * xx + q(3) ) &
      * xx + q(4) ) &
      * xx + q(5)

    result = sump / sumq

    if ( jint == 2 ) then
      result = result * exp ( - x )
    end if

  else if ( one5 <= x ) then

    if ( jint == 1 .and. xmax < x ) then
      result = xinf
    else
!
!  15.0 <= ABS(ARG).
!
      xx = one / x - rec15

      sump = (((((( &
               pp(1) &
        * xx + pp(2) ) &
        * xx + pp(3) ) &
        * xx + pp(4) ) &
        * xx + pp(5) ) &
        * xx + pp(6) ) &
        * xx + pp(7) ) &
        * xx + pp(8)

      sumq = (((((( &
          xx + qq(1) ) &
        * xx + qq(2) ) &
        * xx + qq(3) ) &
        * xx + qq(4) ) &
        * xx + qq(5) ) &
        * xx + qq(6) ) &
        * xx + qq(7)

      result = sump / sumq

      if ( jint == 2 ) then
        result = ( result - pp(1) ) / sqrt ( x )
      else
!
!  Calculation reformulated to avoid premature overflow.
!
        if ( x .le.( xmax - one5 ) ) then
          a = exp ( x )
          b = one
        else
          a = exp ( x - forty )
          b = exp40
        end if

        result = ( ( result * a - pp(1) * a ) / sqrt ( x ) ) * b

      end if

    end if

  end if

  return
end subroutine calci0

subroutine caljy0 ( arg, result, jint )

!*****************************************************************************80
!
!! CALJY0 computes various J0 and Y0 Bessel functions.
!
!  Discussion:
!
!    This routine computes zero-order Bessel functions of the first and
!    second kind (J0 and Y0), for real arguments X, where 0 < X <= XMAX
!    for Y0, and |X| <= XMAX for J0.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Reference:
!
!    John Hart, Ward Cheney, Charles Lawson, Hans Maehly,
!    Charles Mesztenyi, John Rice, Henry Thatcher,
!    Christoph Witzgall,
!    Computer Approximations,
!    Wiley, 1968,
!    LC: QA297.C64.
!
!  Parameters:
!
!    Input, real :: ARG, the argument.  If JINT = 0, ARG
!    must satisfy
!     -XMAX < ARG < XMAX;
!    If JINT = 1, then ARG must satisfy
!      0 < ARG < XMAX.
!
!    Output, real :: RESULT, the value of the function,
!    which depends on the input value of JINT:
!    0, RESULT = J0(x);
!    1, RESULT = Y0(x);
!
!    Input, integer :: JINT, chooses the function to be computed.
!    0, J0(x);
!    1, Y0(x);
!
  implicit none

  integer :: i
  integer :: jint
  real :: arg
  real :: ax
  real :: cons
  real :: down
  real :: eight
  real :: five5
  real :: four
  real :: one
  real :: oneov8
  real :: pi2
  real :: pj0(7)
  real :: pj1(8)
  real :: plg(4)
  real :: prod
  real :: py0(6)
  real :: py1(7)
  real :: py2(8)
  real :: p0(6)
  real :: p1(6)
  real :: p17
  real :: qj0(5)
  real :: qj1(7)
  real :: qlg(4)
  real :: qy0(5)
  real :: qy1(6)
  real :: qy2(7)
  real :: q0(5)
  real :: q1(5)
  real :: resj
  real :: result
  real :: r0
  real :: r1
  real :: sixty4
  real :: three
  real :: twopi
  real :: twopi1
  real :: twopi2
  real :: two56
  real :: up
  real :: w
  real :: wsq
  real :: xden
  real :: xinf
  real :: xmax
  real :: xnum
  real :: xsmall
  real :: xj0
  real :: xj1
  real :: xj01
  real :: xj02
  real :: xj11
  real :: xj12
  real :: xy
  real :: xy0
  real :: xy01
  real :: xy02
  real :: xy1
  real :: xy11
  real :: xy12
  real :: xy2
  real :: xy21
  real :: xy22
  real :: z
  real :: zero
  real :: zsq
!
!  Mathematical constants
!  CONS = ln(.5) + Euler's gamma
!
  data zero / 0.0E0 /
  data one /1.0E0 /
  data three /3.0E0 /
  data four /4.0E0 /
  data eight /8.0E0/
  data five5 / 5.5E0 /
  data sixty4 /64.0E0 /
  data oneov8 /0.125E0 /
  data p17 /1.716E-1/
  data two56 /256.0E0/
  data cons / -1.1593151565841244881E-1/
  data pi2 /6.3661977236758134308E-1/
  data twopi /6.2831853071795864769E0/
  data twopi1 /6.28125E0 /
  data twopi2 / 1.9353071795864769253E-3/

!
!  Zeroes of Bessel functions
!
  data xj0 /2.4048255576957727686E+0/
  data xj1 /5.5200781102863106496E+0/
  data xy0 /8.9357696627916752158E-1/
  data xy1 /3.9576784193148578684E+0/
  data xy2 /7.0860510603017726976E+0/
  data xj01 / 616.0E+0/
  data xj02 /-1.4244423042272313784E-03/
  data xj11 /1413.0E+0/
  data xj12 / 5.4686028631064959660E-04/
  data xy01 / 228.0E+0/
  data xy02 / 2.9519662791675215849E-03/
  data xy11 /1013.0E+0/
  data xy12 / 6.4716931485786837568E-04/
  data xy21 /1814.0E+0/
  data xy22 / 1.1356030177269762362E-04/
!
!  Coefficients for rational approximation to ln(x/a)
!
  data plg/-2.4562334077563243311E+01,2.3642701335621505212E+02, &
           -5.4989956895857911039E+02,3.5687548468071500413E+02/
  data qlg/-3.5553900764052419184E+01,1.9400230218539473193E+02, &
           -3.3442903192607538956E+02,1.7843774234035750207E+02/
!
!  Coefficients for rational approximation of
!  J0(X) / (X**2 - XJ0**2),  XSMALL < |X| <= 4.0
!
  data pj0/6.6302997904833794242E+06,-6.2140700423540120665E+08, &
           2.7282507878605942706E+10,-4.1298668500990866786E+11, &
          -1.2117036164593528341E-01, 1.0344222815443188943E+02, &
          -3.6629814655107086448E+04/
  data qj0/4.5612696224219938200E+05, 1.3985097372263433271E+08, &
           2.6328198300859648632E+10, 2.3883787996332290397E+12, &
           9.3614022392337710626E+02/
!
!  Coefficients for rational approximation of
!  J0(X) / (X**2 - XJ1**2), 4.0 < |X| <= 8.0
!
  data pj1/4.4176707025325087628E+03, 1.1725046279757103576E+04, &
           1.0341910641583726701E+04,-7.2879702464464618998E+03, &
          -1.2254078161378989535E+04,-1.8319397969392084011E+03, &
           4.8591703355916499363E+01, 7.4321196680624245801E+02/
  data qj1/3.3307310774649071172E+02,-2.9458766545509337327E+03, &
           1.8680990008359188352E+04,-8.4055062591169562211E+04, &
           2.4599102262586308984E+05,-3.5783478026152301072E+05, &
          -2.5258076240801555057E+01/
!
!  Coefficients for rational approximation of
!  (Y0(X) - 2 LN(X/XY0) J0(X)) / (X**2 - XY0**2),
!  XSMALL < |X| <= 3.0
!
  data py0/1.0102532948020907590E+04,-2.1287548474401797963E+06, &
           2.0422274357376619816E+08,-8.3716255451260504098E+09, &
           1.0723538782003176831E+11,-1.8402381979244993524E+01/
  data qy0/6.6475986689240190091E+02, 2.3889393209447253406E+05, &
           5.5662956624278251596E+07, 8.1617187777290363573E+09, &
           5.8873865738997033405E+11/
!
!  Coefficients for rational approximation of
!  (Y0(X) - 2 LN(X/XY1) J0(X)) / (X**2 - XY1**2),
!  3.0 < |X| <= 5.5
!
  data py1/-1.4566865832663635920E+04, 4.6905288611678631510E+06, &
           -6.9590439394619619534E+08, 4.3600098638603061642E+10, &
           -5.5107435206722644429E+11,-2.2213976967566192242E+13, &
            1.7427031242901594547E+01/
  data qy1/ 8.3030857612070288823E+02, 4.0669982352539552018E+05, &
            1.3960202770986831075E+08, 3.4015103849971240096E+10, &
            5.4266824419412347550E+12, 4.3386146580707264428E+14/
!
!  Coefficients for rational approximation of
!  (Y0(X) - 2 LN(X/XY2) J0(X)) / (X**2 - XY2**2),
!  5.5 < |X| <= 8.0
!
  data py2/ 2.1363534169313901632E+04,-1.0085539923498211426E+07, &
            2.1958827170518100757E+09,-1.9363051266772083678E+11, &
           -1.2829912364088687306E+11, 6.7016641869173237784E+14, &
           -8.0728726905150210443E+15,-1.7439661319197499338E+01/
  data qy2/ 8.7903362168128450017E+02, 5.3924739209768057030E+05, &
            2.4727219475672302327E+08, 8.6926121104209825246E+10, &
            2.2598377924042897629E+13, 3.9272425569640309819E+15, &
            3.4563724628846457519E+17/
!
!  Coefficients for Hart,s approximation, 8.0 < |X|.
!
  data p0/3.4806486443249270347E+03, 2.1170523380864944322E+04, &
          4.1345386639580765797E+04, 2.2779090197304684302E+04, &
          8.8961548424210455236E-01, 1.5376201909008354296E+02/
  data q0/3.5028735138235608207E+03, 2.1215350561880115730E+04, &
          4.1370412495510416640E+04, 2.2779090197304684318E+04, &
          1.5711159858080893649E+02/
  data p1/-2.2300261666214198472E+01,-1.1183429920482737611E+02, &
          -1.8591953644342993800E+02,-8.9226600200800094098E+01, &
          -8.8033303048680751817E-03,-1.2441026745835638459E+00/
  data q1/1.4887231232283756582E+03, 7.2642780169211018836E+03, &
          1.1951131543434613647E+04, 5.7105024128512061905E+03, &
          9.0593769594993125859E+01/
          !
!  Machine-dependent constants
!
  XMAX = 5*sqrt(1./epsilon(1.))
  XSMALL=0.5*sqrt(epsilon(1.))/radix(1.)
  XINF=huge(1.)
          
!
!  Check for error conditions.
!
  ax = abs ( arg )

  if ( jint == 1 .and. arg <= zero ) then
    result = -xinf
    return
  else if ( xmax < ax ) then
    result = zero
    return
  end if

  if ( eight < ax ) then
    go to 800
  end if

  if ( ax <= xsmall ) then
    if ( jint == 0 ) then
      result = one
    else
      result = pi2 * ( log ( ax ) + cons )
    end if
    return
  end if
!
!  Calculate J0 for appropriate interval, preserving
!  accuracy near the zero of J0.
!
  zsq = ax * ax

  if ( ax <= four ) then
    xnum = ( pj0(5) * zsq + pj0(6) ) * zsq + pj0(7)
    xden = zsq + qj0(5)
    do i = 1, 4
      xnum = xnum * zsq + pj0(i)
      xden = xden * zsq + qj0(i)
    end do
    prod = ( ( ax - xj01 / two56 ) - xj02 ) * ( ax + xj0 )
  else
    wsq = one - zsq / sixty4
    xnum = pj1(7) * wsq + pj1(8)
    xden = wsq + qj1(7)
    do i = 1, 6
      xnum = xnum * wsq + pj1(i)
      xden = xden * wsq + qj1(i)
    end do
    prod = ( ax + xj1 ) * ( ( ax - xj11 / two56 ) - xj12 )
  end if

  result = prod * xnum / xden

  if ( jint == 0 ) then
    return
  end if
!
!  Calculate Y0.  First find  RESJ = pi/2 ln(x/xn) J0(x),
!  where xn is a zero of Y0.
!
  if ( ax <= three ) then
    up = ( ax - xy01 / two56 ) - xy02
    xy = xy0
  else if ( ax <= five5 ) then
    up = ( ax - xy11 / two56 ) - xy12
    xy = xy1
  else
    up = ( ax - xy21 / two56 ) - xy22
    xy = xy2
  end if

  down = ax + xy

  if ( abs ( up ) < p17 * down ) then
    w = up / down
    wsq = w * w
    xnum = plg(1)
    xden = wsq + qlg(1)
    do i = 2, 4
      xnum = xnum * wsq + plg(i)
      xden = xden * wsq + qlg(i)
    end do
    resj = pi2 * result * w * xnum / xden
  else
    resj = pi2 * result * log ( ax / xy )
  end if
!
!  Now calculate Y0 for appropriate interval, preserving
!  accuracy near the zero of Y0.
!
  if ( ax <= three ) then
    xnum = py0(6) * zsq + py0(1)
    xden = zsq + qy0(1)
    do i = 2, 5
      xnum = xnum * zsq + py0(i)
      xden = xden * zsq + qy0(i)
    end do
  else if ( ax <= five5 ) then
    xnum = py1(7) * zsq + py1(1)
    xden = zsq + qy1(1)
    do i = 2, 6
      xnum = xnum * zsq + py1(i)
      xden = xden * zsq + qy1(i)
    end do
  else
    xnum = py2(8) * zsq + py2(1)
    xden = zsq + qy2(1)
    do i = 2, 7
      xnum = xnum * zsq + py2(i)
      xden = xden * zsq + qy2(i)
    end do
  end if

  result = resj + up * down * xnum / xden

  return
!
!  Calculate J0 or Y0 for 8.0 < |ARG|.
!
  800 continue

  z = eight / ax
  w = ax / twopi
  w = aint ( w ) + oneov8
  w = ( ax - w * twopi1 ) - w * twopi2
  zsq = z * z
  xnum = p0(5) * zsq + p0(6)
  xden = zsq + q0(5)
  up = p1(5) * zsq + p1(6)
  down = zsq + q1(5)

  do i = 1, 4
    xnum = xnum * zsq + p0(i)
    xden = xden * zsq + q0(i)
    up = up * zsq + p1(i)
    down = down * zsq + q1(i)
  end do

  r0 = xnum / xden
  r1 = up / down

  if ( jint == 0 ) then
    result = sqrt ( pi2 / ax ) &
      * ( r0 * cos ( w ) - z * r1 * sin ( w ) )
  else
    result = sqrt ( pi2 / ax ) &
      * ( r0 * sin ( w ) + z * r1 * cos ( w ) )
  end if

  return
end subroutine caljy0

subroutine caljy1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALJY1 computes various J1 and Y1 Bessel functions.
!
!  Discussion:
!
!    This routine computes first-order Bessel functions of the first and
!    second kind (J1 and Y1), for real arguments X, where 0 < X <= XMAX
!    for Y1, and |X| <= XMAX for J1.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Reference:
!
!    John Hart, Ward Cheney, Charles Lawson, Hans Maehly,
!    Charles Mesztenyi, John Rice, Henry Thatcher,
!    Christoph Witzgall,
!    Computer Approximations,
!    Wiley, 1968,
!    LC: QA297.C64.
!
!  Parameters:
!
!    Input, real :: ARG, the argument.  If JINT = 0, ARG
!    must satisfy
!     -XMAX < ARG < XMAX;
!    If JINT = 1, then ARG must satisfy
!      0 < ARG < XMAX.
!
!    Output, real :: RESULT, the value of the function,
!    which depends on the input value of JINT:
!    0, RESULT = J1(x);
!    1, RESULT = Y1(x);
!
!    Input, integer :: JINT, chooses the function to be computed.
!    0, J1(x);
!    1, Y1(x);
!
  implicit none

  real :: arg
  real :: ax
  real :: down
  real :: eight
  real :: four
  real :: half
  integer :: i
  integer :: jint
  real :: pi2
  real :: pj0(7)
  real :: pj1(8)
  real :: plg(4)
  real :: prod
  real :: py0(7)
  real :: py1(9)
  real :: p0(6)
  real :: p1(6)
  real :: p17
  real :: qj0(5)
  real :: qj1(7)
  real :: qlg(4)
  real :: qy0(6)
  real :: qy1(8)
  real :: q0(6)
  real :: q1(6)
  real :: resj
  real :: result
  real :: rtpi2
  real :: r0
  real :: r1
  real :: throv8
  real :: twopi
  real :: twopi1
  real :: twopi2
  real :: two56
  real :: up
  real :: w
  real :: wsq
  real :: xden
  real :: xinf
  real :: xmax
  real :: xnum
  real :: xsmall
  real :: xj0
  real :: xj1
  real :: xj01
  real :: xj02
  real :: xj11
  real :: xj12
  real :: xy
  real :: xy0
  real :: xy01
  real :: xy02
  real :: xy1
  real :: xy11
  real :: xy12
  real :: z
  real :: zero
  real :: zsq
!
!  Mathematical constants
!
  data eight /8.0d0/
  data four /4.0d0/
  data half /0.5d0/
  data throv8 /0.375d0/
  data pi2 /6.3661977236758134308d-1/
  data p17 /1.716d-1/
  data twopi /6.2831853071795864769d+0/
  data zero /0.0d0/
  data twopi1 /6.28125d0/
  data twopi2 /1.9353071795864769253d-03/
  data two56 /256.0d+0/
  data rtpi2 /7.9788456080286535588d-1/
!
!  Machine-dependent constants
!
  data xmax /1.07d+09/
  data xsmall /9.31d-10/
  data xinf /1.7d+38/
!
!  Zeroes of Bessel functions
!
  data xj0 /3.8317059702075123156d+0/
  data xj1 /7.0155866698156187535d+0/
  data xy0 /2.1971413260310170351d+0/
  data xy1 /5.4296810407941351328d+0/
  data xj01 / 981.0d+0/
  data xj02 /-3.2527979248768438556d-04/
  data xj11 /1796.0d+0/
  data xj12 /-3.8330184381246462950d-05/
  data xy01 / 562.0d+0/
  data xy02 / 1.8288260310170351490d-03/
  data xy11 /1390.0d+0/
  data xy12 /-6.4592058648672279948d-06/
!
!  Coefficients for rational approximation to ln(x/a)
!
  data plg/-2.4562334077563243311d+01,2.3642701335621505212d+02, &
           -5.4989956895857911039d+02,3.5687548468071500413d+02/
  data qlg/-3.5553900764052419184d+01,1.9400230218539473193d+02, &
           -3.3442903192607538956d+02,1.7843774234035750207d+02/
!
!  Coefficients for rational approximation of
!  J1(X) / (X * (X**2 - XJ0**2)), XSMALL < |X| <=  4.0
!
  data pj0/9.8062904098958257677d+05,-1.1548696764841276794d+08, &
         6.6781041261492395835d+09,-1.4258509801366645672d+11, &
        -4.4615792982775076130d+03, 1.0650724020080236441d+01, &
        -1.0767857011487300348d-02/
  data qj0/5.9117614494174794095d+05, 2.0228375140097033958d+08, &
         4.2091902282580133541d+10, 4.1868604460820175290d+12, &
         1.0742272239517380498d+03/
!
!  Coefficients for rational approximation of
!  J1(X) / (X * (X**2 - XJ1**2)), 4.0 < |X| <= 8.0
!
  data pj1/4.6179191852758252280d+00,-7.1329006872560947377d+03, &
         4.5039658105749078904d+06,-1.4437717718363239107d+09, &
         2.3569285397217157313d+11,-1.6324168293282543629d+13, &
         1.1357022719979468624d+14, 1.0051899717115285432d+15/
  data qj1/1.1267125065029138050d+06, 6.4872502899596389593d+08, &
         2.7622777286244082666d+11, 8.4899346165481429307d+13, &
         1.7128800897135812012d+16, 1.7253905888447681194d+18, &
         1.3886978985861357615d+03/
!
!  Coefficients for rational approximation of
!  (Y1(X) - 2 LN(X/XY0) J1(X)) / (X**2 - XY0**2),
!  XSMALL < |X| <=  4.0
!
  data py0/2.2157953222280260820d+05,-5.9157479997408395984d+07, &
           7.2144548214502560419d+09,-3.7595974497819597599d+11, &
           5.4708611716525426053d+12, 4.0535726612579544093d+13, &
          -3.1714424660046133456d+02/
  data qy0/8.2079908168393867438d+02, 3.8136470753052572164d+05, &
           1.2250435122182963220d+08, 2.7800352738690585613d+10, &
           4.1272286200406461981d+12, 3.0737873921079286084d+14/
!
!  Coefficients for rational approximation of
!  (Y1(X) - 2 LN(X/XY1) J1(X)) / (X**2 - XY1**2),
!  4.0 < |X| <= 8.0
!
  data py1/ 1.9153806858264202986d+06,-1.1957961912070617006d+09, &
            3.7453673962438488783d+11,-5.9530713129741981618d+13, &
            4.0686275289804744814d+15,-2.3638408497043134724d+16, &
           -5.6808094574724204577d+18, 1.1514276357909013326d+19, &
           -1.2337180442012953128d+03/
  data qy1/ 1.2855164849321609336d+03, 1.0453748201934079734d+06, &
            6.3550318087088919566d+08, 3.0221766852960403645d+11, &
            1.1187010065856971027d+14, 3.0837179548112881950d+16, &
            5.6968198822857178911d+18, 5.3321844313316185697d+20/
!
!  Coefficients for Hart's approximation, 8.0 < |X|.
!
  data p0/-1.0982405543459346727d+05,-1.5235293511811373833d+06, &
           -6.6033732483649391093d+06,-9.9422465050776411957d+06, &
           -4.4357578167941278571d+06,-1.6116166443246101165d+03/
  data q0/-1.0726385991103820119d+05,-1.5118095066341608816d+06, &
           -6.5853394797230870728d+06,-9.9341243899345856590d+06, &
           -4.4357578167941278568d+06,-1.4550094401904961825d+03/
  data p1/ 1.7063754290207680021d+03, 1.8494262873223866797d+04, &
            6.6178836581270835179d+04, 8.5145160675335701966d+04, &
            3.3220913409857223519d+04, 3.5265133846636032186d+01/
  data q1/ 3.7890229745772202641d+04, 4.0029443582266975117d+05, &
            1.4194606696037208929d+06, 1.8194580422439972989d+06, &
            7.0871281941028743574d+05, 8.6383677696049909675d+02/
!
!  Check for error conditions.
!
  ax = abs ( arg )

  if ( jint == 1 .and. ( arg <= zero .or. &
    ( arg < half .and. ax * xinf < pi2 ) ) ) then
    result = -xinf
    return
  else if ( xmax < ax ) then
    result = zero
    return
  end if

  if ( eight < ax ) then
    go to 800
  else if ( ax <= xsmall ) then
    if ( jint == 0 ) then
      result = arg * half
    else
      result = -pi2 / ax
    end if
    return
  end if
!
!  Calculate J1 for appropriate interval, preserving
!  accuracy near the zero of J1.
!
  zsq = ax * ax

  if ( ax <= four ) then
    xnum = ( pj0(7) * zsq + pj0(6) ) * zsq + pj0(5)
    xden = zsq + qj0(5)
    do i = 1, 4
      xnum = xnum * zsq + pj0(i)
      xden = xden * zsq + qj0(i)
    end do
    prod = arg * ( ( ax - xj01 / two56 ) - xj02 ) * ( ax + xj0 )
  else
    xnum = pj1(1)
    xden = ( zsq + qj1(7) ) * zsq + qj1(1)
    do i = 2, 6
      xnum = xnum * zsq + pj1(i)
      xden = xden * zsq + qj1(i)
    end do
    xnum = xnum * ( ax - eight ) * ( ax + eight ) + pj1(7)
    xnum = xnum * ( ax - four ) * ( ax + four ) + pj1(8)
    prod = arg * ( ( ax - xj11 / two56 ) - xj12 ) * ( ax + xj1 )
  end if

  result = prod * ( xnum / xden )

  if ( jint == 0 ) then
    return
  end if
!
!  Calculate Y1.  First find RESJ = pi/2 ln(x/xn) J1(x),
!  where xn is a zero of Y1.
!
  if ( ax <= four ) then
    up = ( ax - xy01 / two56 ) - xy02
    xy = xy0
  else
    up = ( ax - xy11 / two56 ) - xy12
    xy = xy1
  end if

  down = ax + xy

  if ( abs ( up ) < p17 * down ) then
    w = up / down
    wsq = w * w
    xnum = plg(1)
    xden = wsq + qlg(1)
    do i = 2, 4
      xnum = xnum * wsq + plg(i)
      xden = xden * wsq + qlg(i)
    end do
    resj = pi2 * result * w * xnum / xden
  else
    resj = pi2 * result * log ( ax / xy )
  end if
!
!  Now calculate Y1 for appropriate interval, preserving
!  accuracy near the zero of Y1.
!
  if ( ax <= four ) then
    xnum = py0(7) * zsq + py0(1)
    xden = zsq + qy0(1)
    do i = 2, 6
      xnum = xnum * zsq + py0(i)
      xden = xden * zsq + qy0(i)
    end do
  else
    xnum = py1(9) * zsq + py1(1)
    xden = zsq + qy1(1)
    do i = 2, 8
      xnum = xnum * zsq + py1(i)
      xden = xden * zsq + qy1(i)
    end do
  end if

  result = resj + ( up * down / ax ) * xnum / xden
  return
!
!  Calculate J1 or Y1 for 8.0 < |ARG|.
!
  800 continue

  z = eight / ax
  w = aint ( ax / twopi ) + throv8
  w = ( ax - w * twopi1 ) - w * twopi2
  zsq = z * z
  xnum = p0(6)
  xden = zsq + q0(6)
  up = p1(6)
  down = zsq + q1(6)

  do i = 1, 5
    xnum = xnum * zsq + p0(i)
    xden = xden * zsq + q0(i)
    up = up * zsq + p1(i)
    down = down * zsq + q1(i)
  end do

  r0 = xnum / xden
  r1 = up / down

  if ( jint == 0 ) then
    result = ( rtpi2 / sqrt ( ax ) ) &
      * ( r0 * cos ( w ) - z * r1 * sin ( w ) )
  else
    result = ( rtpi2 / sqrt ( ax ) ) &
      * ( r0 * sin ( w ) + z * r1 * cos ( w ) )
  end if

  if ( jint == 0 .and. arg < zero ) then
    result = -result
  end if

  return
end subroutine caljy1


function besei0 ( x )

!*****************************************************************************80
!
!! BESEI0 evaluates the exponentially scaled Bessel I0(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for the modified Bessel
!    function of the first kind of order zero multiplied by EXP(-ABS(X)).
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: BESEI0, the value of the function.
!
  implicit none

  real    :: besei0
  integer :: jint
  real    :: result
  real    :: x

  jint = 2
  call calci0 ( x, result, jint )
  besei0 = result

  return
end function besei0

function besei1 (x)

!*****************************************************************************80
!
!! BESEI1 evaluates the exponentially scaled Bessel I1(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for the
!    modified Bessel function of the first kind of order one
!    multiplied by EXP(-ABS(X)).
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: BESEI1, the value of the function.
!
  implicit none

  real :: besei1
  integer :: jint
  real :: result
  real, intent(in) :: x

  jint = 2
  call calci1 ( x, result, jint )
  besei1 = result

end function besei1


function besi_0 ( x )

!*****************************************************************************80
!
!! BESI0 evaluates the Bessel I0(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for
!    modified Bessel functions of the first kind of order zero for
!    arguments ABS(ARG) <= XMAX.
!
!    See comments heading CALCI0.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: BESI0, the value of the function.
!
  implicit none

  real :: besi_0
  integer :: jint
  real :: result
  real :: x

  jint = 1
  call calci0 ( x, result, jint )
  besi_0 = result

  return
end function besi_0


function besj_0 ( x )

!*****************************************************************************80
!
!! BESJ0 evaluates the Bessel J0(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for Bessel functions
!    of the first kind of order zero for arguments  |X| <= XMAX
!
!    See comments heading CALJY0.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: BESJ0, the value of the function.
!
  implicit none

  real :: besj_0
  integer :: jint
  real :: result
  real :: x

  jint = 0
  call caljy0 ( x, result, jint )
  besj_0 = result

  return
end function besj_0


function besj_1 ( x )

!*****************************************************************************80
!
!! BESJ1 evaluates the Bessel J1(X) function.
!
!  Discussion:
!
!    This routine computes approximate values for Bessel functions
!    of the first kind of order zero for arguments  |X| <= XMAX
!
!    See comments heading CALJY1.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Parameters:
!
!    Input, real :: X, the argument of the function.
!
!    Output, real :: BESJ1, the value of the function.
!
  implicit none

  real :: besj_1
  integer :: jint
  real :: result
  real :: x

  jint = 0
  call caljy1 ( x, result, jint )
  besj_1 = result

  return
end function besj_1

subroutine calci1 ( arg, result, jint )

!*****************************************************************************80
!
!! CALCI1 computes various I1 Bessel functions.
!
!  Discussion:
!
!    This routine computes modified Bessel functioons of the first kind
!    and order one, I1(X) and EXP(-ABS(X))*I1(X), for real
!    arguments X.
!
!    The main computation evaluates slightly modified forms of
!    minimax approximations generated by Blair and Edwards, Chalk
!    River (Atomic Energy of Canada Limited) Report AECL-4928,
!    October, 1974.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody, Laura Stoltz
!
!  Parameters:
!
!    Input, real :: ARG, the argument.  If JINT = 1, then
!    the argument must be less than XMAX.
!
!    Output, real :: RESULT, the value of the function,
!    which depends on the input value of JINT:
!    1, RESULT = I1(x);
!    2, RESULT = exp(-x) * I1(x);
!
!    Input, integer :: JINT, chooses the function to be computed.
!    1, I1(x);
!    2, exp(-x) * I1(x);
!
  implicit none

  real :: a
  real, intent(in) :: arg
  real :: b
  real :: exp40
  real :: forty
  real :: half
  integer :: j
  integer, intent(in) :: jint
  real :: one
  real :: one5
  real :: p(15)
  real :: pbar
  real :: pp(8)
  real :: q(5)
  real :: qq(6)
  real :: rec15
  real, intent(out) :: result
  real :: sump
  real :: sumq
  real :: two25
  real :: x
  real :: xinf
  real :: xmax
  real :: xsmall
  real :: xx
  real :: zero
!
!  Mathematical constants
!
  data one /1.0E0/
  data one5 /15.0E0/
  data exp40 /2.353852668370199854E17/
  data forty /40.0E0/
  data rec15 /6.6666666666666666666e-2/
  data two25 /225.0E0/
  data half /0.5E0/
  data zero /0.0E0/
!
!  Coefficients for XSMALL <= ABS(ARG) < 15.0
!
  data p/-1.9705291802535139930E-19,-6.5245515583151902910e-16, &
         -1.1928788903603238754E-12,-1.4831904935994647675E-09, &
         -1.3466829827635152875e-06,-9.1746443287817501309E-04, &
         -4.7207090827310162436e-01,-1.8225946631657315931E+02, &
         -5.1894091982308017540E+04,-1.0588550724769347106E+07, &
         -1.4828267606612366099e+09,-1.3357437682275493024E+11, &
         -6.9876779648010090070E+12,-1.7732037840791591320E+14, &
         -1.4577180278143463643E+15/
  data q/-4.0076864679904189921e+03, 7.4810580356655069138e+06, &
         -8.0059518998619764991e+09, 4.8544714258273622913e+12, &
         -1.3218168307321442305e+15/
!
!  Coefficients for 15.0 <= ABS(ARG)
!
  data pp/-6.0437159056137600000e-02, 4.5748122901933459000e-01, &
          -4.2843766903304806403e-01, 9.7356000150886612134e-02, &
          -3.2457723974465568321e-03,-3.6395264712121795296e-04, &
           1.6258661867440836395e-05,-3.6347578404608223492e-07/
  data qq/-3.8806586721556593450e+00, 3.2593714889036996297e+00, &
          -8.5017476463217924408e-01, 7.4212010813186530069e-02, &
          -2.2835624489492512649e-03, 3.7510433111922824643e-05/
  data pbar/3.98437500e-01/

!
!  Machine-dependent constants
!
   xsmall = epsilon(1.)
   xinf = huge(1.)
   XMAX = 5*sqrt(1./epsilon(1.))


  x = abs ( arg )
!
!  Return for ABS(ARG) < XSMALL.
!
  if ( x < xsmall ) then

    result = half * x
!
!  XSMALL <= ABS(ARG) < 15.0.
!
  else if ( x < one5 ) then

    xx = x * x
    sump = p(1)
    do j = 2, 15
      sump = sump * xx + p(j)
    end do
    xx = xx - two25

    sumq = (((( &
        xx + q(1) ) &
      * xx + q(2) ) &
      * xx + q(3) ) &
      * xx + q(4) ) &
      * xx + q(5)

    result = ( sump / sumq ) * x

    if ( jint == 2 ) then
      result = result * exp ( -x )
    end if

  else if ( jint == 1 .and. xmax < x ) then

    result = xinf

  else
!
!  15.0 <= ABS(ARG).
!
    xx = one / x - rec15

    sump = (((((( &
             pp(1) &
      * xx + pp(2) ) &
      * xx + pp(3) ) &
      * xx + pp(4) ) &
      * xx + pp(5) ) &
      * xx + pp(6) ) &
      * xx + pp(7) ) &
      * xx + pp(8)

    sumq = ((((( &
        xx + qq(1) ) &
      * xx + qq(2) ) &
      * xx + qq(3) ) &
      * xx + qq(4) ) &
      * xx + qq(5) ) &
      * xx + qq(6)

    result = sump / sumq

    if ( jint /= 1 ) then
      result = ( result + pbar ) / sqrt ( x )
    else
!
!  Calculation reformulated to avoid premature overflow.
!
      if ( xmax - one5 < x ) then
        a = exp ( x - forty )
        b = exp40
      else
        a = exp ( x )
        b = one
      end if

      result = ( ( result * a + pbar * a ) / sqrt ( x ) ) * b

    end if
  end if

  if ( arg < zero ) then
    result = -result
  end if

  return

end subroutine calci1

subroutine calerf ( arg, result, jint )

!*****************************************************************************80
!
!! CALERF computes various forms of the error function.
!
!  Discussion:
!
!    This routine evaluates erf(x), erfc(x), and exp(x*x)*erfc(x)
!    for a real argument x.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Reference:
!
!    William Cody,
!    Rational Chebyshev Approximations for the Error Function,
!    Mathematics of Computation,
!    Volume 23, Number 107, July 1969, pages 631-638.
!
!  Parameters:
!
!    Input, real :: ARG, the argument.  If JINT is 1, the
!    argument must be less than XBIG.  If JINT is 2, the argument
!    must lie between XNEG and XMAX.
!
!    Output, real :: RESULT, the value of the function,
!    which depends on the input value of JINT:
!    0, RESULT = erf(x);
!    1, RESULT = erfc(x) = 1 - erf(x);
!    2, RESULT = exp(x*x)*erfc(x) = exp(x*x) - erf(x*x)*erf(x).
!
!    Input, integer :: JINT, chooses the function to be computed.
!    0, erf(x);
!    1, erfc(x);
!    2, exp(x*x)*erfc(x).
!
  implicit none

  real :: a(5)
  real :: arg
  real :: b(4)
  real :: c(9)
  real :: d(8)
  real :: del
  real :: four
  real :: half
  integer :: i
  integer :: jint
  real :: one
  real :: p(6)
  real :: q(5)
  real :: result
  real :: sixten
  real :: sqrpi
  real :: two
  real :: thresh
  real :: x
  real :: xbig
  real :: xden
  real :: xhuge
  real :: xinf
  real :: xmax
  real :: xneg
  real :: xnum
  real :: xsmall
  real :: y
  real :: ysq
  real :: zero
  real :: pi
  real :: xmin
!
!  Mathematical constants
!
  data four /4.0E0/
  data one /1.0E0/
  data half /0.5E0/
  data two /2.0E0/
  data zero /0.0E0/
  data sqrpi /5.6418958354775628695E-1/
  data thresh /0.46875E0/
  data sixten /16.0E0/
  data pi     /3.141592653589793238462643383279E0/

!
!  Coefficients for approximation to  erf  in first interval
!
  data a/3.16112374387056560E00,1.13864154151050156E02, &
         3.77485237685302021E02,3.20937758913846947E03, &
         1.85777706184603153E-1/
  data b/2.36012909523441209E01,2.44024637934444173E02, &
         1.28261652607737228E03,2.84423683343917062E03/
!
!  Coefficients for approximation to  erfc  in second interval
!
  data c/5.64188496988670089E-1,8.88314979438837594E0, &
         6.61191906371416295E01,2.98635138197400131E02, &
         8.81952221241769090E02,1.71204761263407058E03, &
         2.05107837782607147E03,1.23033935479799725E03, &
         2.15311535474403846E-8/
  data d/1.57449261107098347E01,1.17693950891312499E02, &
         5.37181101862009858E02,1.62138957456669019E03, &
         3.29079923573345963E03,4.36261909014324716E03, &
         3.43936767414372164E03,1.23033935480374942E03/
!
!  Coefficients for approximation to  erfc  in third interval
!
  data p/3.05326634961232344E-1,3.60344899949804439E-1, &
         1.25781726111229246E-1,1.60837851487422766E-2, &
         6.58749161529837803E-4,1.63153871373020978E-2/
  data q/2.56852019228982242E00,1.87295284992346047E00, &
         5.27905102951428412E-1,6.05183413124413191E-2, &
         2.33520497626869185E-3/

!
!  Machine-dependent constants
!
!  data xinf /1.79E308 /
!  data xneg / -26.628E0 /
!  data xbig /26.543E0 /
!  data xhuge /6.71E7/

  XSMALL=epsilon(1.)
  XMIN=tiny(1.)
  XINF=huge(1.)
  XBIG=26.543E0
  XNEG=-26.628E0
  XMAX = min( XINF,1/(sqrt(pi)*XMIN ) )
  XHUGE= 1/(2*sqrt(XSMALL))

  x = arg
  y = abs ( x )
!
!  Evaluate erf for |X| <= 0.46875.
!
  if ( y <= thresh ) then

    ysq = zero
    if ( xsmall < y ) then
      ysq = y * y
    end if

    xnum = a(5) * ysq
    xden = ysq

    do i = 1, 3
      xnum = ( xnum + a(i) ) * ysq
      xden = ( xden + b(i) ) * ysq
    end do

    result = x * ( xnum + a(4) ) / ( xden + b(4) )

    if ( jint /= 0 ) then
      result = one - result
    end if

    if ( jint == 2 ) then
      result = exp ( ysq ) * result
    end if

    return
!
!  Evaluate erfc for 0.46875 <= |X| <= 4.0.
!
   else if ( y <= four ) then

     xnum = c(9) * y
     xden = y

     do i = 1, 7
       xnum = ( xnum + c(i) ) * y
       xden = ( xden + d(i) ) * y
     end do

     result = ( xnum + c(8) ) / ( xden + d(8) )

     if ( jint /= 2 ) then
       ysq = aint ( y * sixten ) / sixten
       del = ( y - ysq ) * ( y + ysq )
       result = exp ( -ysq * ysq ) * exp ( -del ) * result
     end if
!
!  Evaluate erfc for 4.0 < |X|.
!
   else

     result = zero

     if ( xbig <= y ) then

       if ( jint /= 2 .or. xmax <= y ) then
         go to 300
       end if

       if ( xhuge <= y ) then
         result = sqrpi / y
         go to 300
       end if

     end if

     ysq = one / ( y * y )
     xnum = p(6) * ysq
     xden = ysq
     do i = 1, 4
       xnum = ( xnum + p(i) ) * ysq
       xden = ( xden + q(i) ) * ysq
      end do

      result = ysq * ( xnum + p(5) ) / ( xden + q(5) )
      result = ( sqrpi -  result ) / y

      if ( jint /= 2 ) then
        ysq = aint ( y * sixten ) / sixten
        del = ( y - ysq ) * ( y + ysq )
        result = exp ( -ysq * ysq ) * exp ( -del ) * result
      end if

  end if
!
!  Fix up for negative argument, erf, etc.
!
  300 continue

  if ( jint == 0 ) then

    result = ( half - result ) + half
    if ( x < zero ) then
      result = -result
    end if

  else if ( jint == 1 ) then

    if ( x < zero ) then
      result = two - result
    end if

  else

    if ( x < zero ) then

      if ( x < xneg ) then
        result = xinf
      else
        ysq = aint ( x * sixten ) / sixten
        del = ( x - ysq ) * ( x + ysq )
        y = exp ( ysq * ysq ) * exp ( del )
        result = ( y + y ) - result
      end if

    end if

  end if

  return
end subroutine calerf

subroutine machar ( ibeta, it, irnd, ngrd, machep, negep, iexp, &
  minexp, maxexp, eps, epsneg, xmin, xmax )

!*****************************************************************************80
!
!! MACHAR determines various machine arithmetic parameters.
!
!  Discussion:
!
!    This routine is intended to determine the parameters
!    of the floating-point arithmetic system specified below.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Reference:
!
!    William Cody, William Waite,
!    Software Manual for the Elementary Functions,
!    Prentice Hall, 1980,
!    ISBN: 0138220646,
!    LC: QA331.C635.
!
!    Michael Malcolm,
!    Algorithms to Reveal Properties of Floating Point Arithmetic,
!    Communications of the ACM,
!    Volume 15, Number 11, November 1972, pages 949-951.
!
!  Parameters:
!
!    Output, integer :: IBETA, the radix for the floating-point representation
!
!    Output, integer :: IT, the number of base IBETA digits in the floating-point
!    significand.
!
!    Output, integer :: IRND.
!    * 0, if floating-point addition chops;
!    * 1, if floating-point addition rounds, but not in the IEEE style;
!    * 2, if floating-point addition rounds in the IEEE style;
!    * 3, if floating-point addition chops, and there is partial underflow;
!    * 4, if floating-point addition rounds, but not in the IEEE style,
!      and there is partial underflow
!    * 5, if floating-point addition rounds in the IEEE style, and there
!      is partial underflow
!
!    Output, integer :: NGRD, the number of guard digits for multiplication with
!    truncating arithmetic.  It is
!    * 0, if floating-point arithmetic rounds, or if it truncates and only
!      IT base IBETA digits participate in the post-normalization shift of the
!      floating-point significand in multiplication;
!    * 1, if floating-point arithmetic truncates and more than IT base IBETA
!      digits participate in the post-normalization shift of the floating-point
!      significand in multiplication.
!
!    Output, integer :: MACHEP. the largest negative integer such that
!    1.0+FLOAT(IBETA)**MACHEP .NE. 1.0, except that MACHEP is bounded below
!    by  -(IT+3).
!
!    Output, integer :: NEGEPS. the largest negative integer such that
!    1.0-FLOAT(IBETA)**NEGEPS .NE. 1.0, except that NEGEPS is bounded below
!    by  -(IT+3).
!
!    Output, integer :: IEXP, the number of bits (decimal places if IBETA = 10)
!    reserved for the representation of the exponent, including the bias or
!    sign, of a floating-point number.
!
!    Output, integer :: MINEXP, largest magnitude negative integer such that
!    FLOAT(IBETA)**MINEXP is positive and normalized.
!
!    Output, integer :: MAXEXP, the smallest positive power of BETA that
!    overflows.
!
!    Output, real :: EPS, the value FLOAT(IBETA)**MACHEP.
!
!    Output, real :: EPSNEG, the value FLOAT(IBETA)**NEGEPS.
!
!    Output, real :: XMIN, the smallest non-vanishing normalized
!    floating-point power of the radix, that is, XMIN = FLOAT(IBETA)**MINEXP.
!
!    Output, real :: XMAX, the largest finite floating-point number.
!    In particular XMAX = (1.0-EPSNEG)*FLOAT(IBETA)**MAXEXP.
!    On some machines  XMAX  will be only the second, or perhaps third,
!    largest number, being too small by 1 or 2 units in the last digit of
!    the significand.
!

  use global, only : gkw_a_equal_b_accuracy

  implicit none

  real :: a
  real :: b
  real :: beta
  real :: betain
  real :: betah
  real :: eps
  real :: epsneg
  integer :: i
  integer :: ibeta
  integer :: iexp
  integer :: irnd
  integer :: it
  integer :: itemp
  integer :: iz
  integer :: j
  integer :: k
  integer :: machep
  integer :: maxexp
  integer :: minexp
  integer :: mx
  integer :: negep
  integer :: ngrd
  integer :: nxres
  real :: one
  real :: t
  real :: temp
  real :: tempa
  real :: temp1
  real :: two
  real :: xmax
  real :: xmin
  real :: y
  real :: z
  real :: zero

  one = real ( 1.)
  two = one + one
  zero = one - one
!
!  Determine IBETA, BETA ala Malcolm.
!
  a = one
   10 continue
  a = a + a
  temp = a + one
  temp1 = temp - a
  if (gkw_a_equal_b_accuracy(temp1, one)) then
    go to 10
  end if

  b = one
   20 continue
  b = b + b
  temp = a + b
  itemp = int ( temp - a )
  if ( itemp == 0 ) then
    go to 20
  end if

  ibeta = itemp
  beta = real ( ibeta)
!
!  Determine IT, IRND.
!
  it = 0
  b = one
  100 continue
  it = it + 1
  b = b * beta
  temp = b + one
  temp1 = temp - b
  if (gkw_a_equal_b_accuracy(temp1, one)) then
    go to 100
  end if

  irnd = 0
  betah = beta / two
  temp = a + betah

  if (.not. gkw_a_equal_b_accuracy(temp, a)) then
    irnd = 1
  end if

  tempa = a + beta
  temp = tempa + betah

  if ( irnd == 0 .and. (.not. gkw_a_equal_b_accuracy(temp, tempa)) ) then
    irnd = 2
  end if
!
!  Determine NEGEP, EPSNEG.
!
  negep = it + 3
  betain = one / beta
  a = one
  do i = 1, negep
     a = a * betain
  end do

  b = a
  210 continue
  temp = one - a
  if (gkw_a_equal_b_accuracy(temp, one)) then
    a = a * beta
    negep = negep - 1
    go to 210
  end if

  negep = -negep
  epsneg = a
!
!  Determine MACHEP, EPS.
!
  machep = -it - 3
  a = b
  300 continue
  temp = one + a
  if (gkw_a_equal_b_accuracy(temp, one)) then
    a = a * beta
    machep = machep + 1
    go to 300
  end if

  eps = a
!
!  Determine NGRD.
!
  ngrd = 0
  temp = one + eps

  if ( irnd == 0 .and. (.not. gkw_a_equal_b_accuracy(temp * one, one)) ) then
    ngrd = 1
  end if
!
!  Determine IEXP, MINEXP, XMIN.
!
!  Loop to determine largest I and K = 2**I such that
!    (1/BETA) ** (2**(I))
!  does not underflow.
!  Exit from loop is signaled by an underflow.
!
  i = 0
  k = 1
  z = betain
  t = one + eps
  nxres = 0
  400 continue
  y = z
  z = y * y
!
!  Check for underflow here.
!
  a = z * one
  temp = z * t

  if ( gkw_a_equal_b_accuracy(a + a, zero) .or. y <= abs ( z ) ) then
    go to 410
  end if

  temp1 = temp * betain
  if (gkw_a_equal_b_accuracy(temp1 * beta, z)) then
    go to 410
  end if

  i = i + 1
  k = k + k
  go to 400

  410 continue
  if ( ibeta == 10 ) then
    go to 420
  end if

  iexp = i + 1
  mx = k + k
  go to 450
!
!  This segment is for decimal machines only.
!
  420 continue

  iexp = 2

  iz = ibeta

  430 continue

  if ( iz <= k ) then
    iz = iz * ibeta
    iexp = iexp + 1
    go to 430
  end if

  mx = iz + iz - 1
!
!  Loop to determine MINEXP, XMIN.
!  Exit from loop is signaled by an underflow.
!
  450 continue

  xmin = y
  y = y * betain
!
!  Check for underflow here.
!
  a = y * one
  temp = y * t
  if ( gkw_a_equal_b_accuracy(a + a, zero) .or. xmin <= abs ( y ) ) then
    go to 460
  end if

  k = k + 1
  temp1 = temp * betain
  if ( (.not. gkw_a_equal_b_accuracy(temp1 * beta, y)) &
      & .or. gkw_a_equal_b_accuracy(temp, y)) then
    go to 450
  else
    nxres = 3
    xmin = y
  end if

  460 continue

  minexp = -k
!
!  Determine MAXEXP, XMAX.
!
  if ( k + k - 3 < mx .or. ibeta == 10 ) then
    go to 500
  end if

  mx = mx + mx
  iexp = iexp + 1

  500 continue

  maxexp = mx + minexp
!
!  Adjust IRND to reflect partial underflow.
!
  irnd = irnd + nxres
!
!  Adjust for IEEE-style machines.
!
  if ( 2 <= irnd ) then
    maxexp = maxexp - 2
  end if
!
!  Adjust for machines with implicit leading bit in binary
!  significand, and machines with radix point at extreme
!  right of significand.
!
  i = maxexp + minexp

  if ( ibeta == 2 .and. i == 0 ) then
    maxexp = maxexp - 1
  end if

  if ( 20 < i ) then
    maxexp = maxexp - 1
  end if

  if (.not. gkw_a_equal_b_accuracy(a, y)) then
    maxexp = maxexp - 2
  end if

  xmax = one - epsneg

  if ( .not. gkw_a_equal_b_accuracy(xmax * one, xmax) ) then
    xmax = one - beta * epsneg
  end if

  xmax = xmax / ( beta * beta * beta * xmin )
  i = maxexp + minexp + 3

  do j = 1, i
    if ( ibeta == 2 ) then
      xmax = xmax + xmax
    else
      xmax = xmax * beta
    end if
  end do

  return
end subroutine machar

function ren ( )

!*****************************************************************************80
!
!! REN is a random number generator.
!
!  Discussion:
!
!    This routine is intended for use on computers with
!    fixed point wordlength of at least 29 bits.  It is
!    best if the floating-point significand has at most
!    29 bits.
!
!  Modified:
!
!    03 April 2007
!
!  Author:
!
!    William Cody
!
!  Reference:
!
!    Malcolm Pike, David Hill,
!    Algorithm 266:
!    Pseudo-Random Numbers,
!    Communications of the ACM,
!    Volume 8, Number 10, October 1965, page 605.
!
!  Parameters:
!
!    Input, integer :: K, a seed for the random number generator.
!    (Not actually used.)
!
!    Output, real :: REN, a pseudorandom value.
!
  implicit none

  real    , parameter :: c1 = 2796203.0E+00
  real    , parameter :: c2 = 1.0E-06
  real    , parameter :: c3 = 1.0E-12
  integer :: iy
  real    :: ren

  save iy

  data iy / 100001 /

  iy = iy * 125
  iy = iy - ( iy / 2796203 ) * 2796203
  ren = real ( iy) / c1 * ( 1.0E+00 + c2 + c3 )

  return
end function ren

function timestamp ( )

!*****************************************************************************80
!
!! TIMESTAMP prints the current YMDHMS date as a time stamp.
!
!  Example:
!
!    31 May 2001   9:45:54.872 AM
!
!  Modified:
!
!    06 August 2005
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    None
!

  character (len=128) :: timestamp
  character ( len = 8 ) ampm
  integer :: d
  integer :: h
  integer :: m
  integer :: mm
  character ( len = 9 ), parameter, dimension(12) :: month = (/ &
    'January  ', 'February ', 'March    ', 'April    ', &
    'May      ', 'June     ', 'July     ', 'August   ', &
    'September', 'October  ', 'November ', 'December ' /)
  integer :: n
  integer :: s
  integer :: values(8)
  integer :: y

  call date_and_time ( values = values )

  y = values(1)
  m = values(2)
  d = values(3)
  h = values(5)
  n = values(6)
  s = values(7)
  mm = values(8)

  if ( h < 12 ) then
    ampm = 'AM'
  else if ( h == 12 ) then
    if ( n == 0 .and. s == 0 ) then
      ampm = 'Noon'
    else
      ampm = 'PM'
    end if
  else
    h = h - 12
    if ( h < 12 ) then
      ampm = 'PM'
    else if ( h == 12 ) then
      if ( n == 0 .and. s == 0 ) then
        ampm = 'Midnight'
      else
        ampm = 'AM'
      end if
    end if
  end if

!  write ( *, '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
!    d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm )
write (timestamp, '(i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) &
    d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm )


end function timestamp

end module specfun
